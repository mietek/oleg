(* coercion.sml *)

(* I advise you to read the user documentation for LEGO with coercion
   synthesis!

   1. Overview Of Coercions

   The user is allowed to specify that certain functional LEGO
   terms be coercions. This means that they can be left implicit
   when writing LEGO expressions. When LEGO turns the concrete
   input syntax into the abstract syntax of the type theory,
   it synthesises these coercions automatically, and marks them
   so that they can be suppressed at output also if that is so
   desired.

   Obviously there are various limitations that must be placed
   on the declaration of these coercions if the syntax of LEGO
   expressions that leave them implicit is to remain unambiguous.
   It must be the case that a coercion is only synthesised if
   the expression is not already well-formed, and that whenever
   a coercion is synthesised, there must be only one possible
   candidate for use. This is the coherency requirement.

   This implementation is based on the previous unofficial version
   of LEGOwc that I implemented. It differs in several ways.
   However, almost all scripts that worked with LEGOwc should work
   with this new version. (The need for the modifier "almost" arises
   because in fact the mechanism that was used to make new coercions
   out of old ones in the previous version was not as generic as
   it should have been. Although the version was very useable and
   I had no problems in practice, it was possible to declare certain
   pathological parameterised coercions in such a way as to generate
   subtle incoherencies. Also, the new version will generate more
   new coercions than the previous one, again meaning that the
   entire coercive graph generated by the new version from
   declarations acceptable to the previous version can be incoherent
   and will hence be rejected. For what it's worth, none of my
   old LEGO scripts have caused such problems.)

   2. Two Design Decisions

   There are two design decisions that should be understood.
   These are using static rather than dynamic coercion generation,
   and a syntactically based type-matching rather than full
   convertibility when synthesising coercions.

   By static coercion generation, I mean that when a new coercion
   is declared, LEGO at that point generates all the (possibly
   parameterised) paths through the coercive graph that it will
   use. This is less general than the alternative mechanism of
   dynamic generation of a path at the moment when a coercion
   needs to be synthesised, since such a mechanism makes such
   tricks as the contravariant use of coercions on the sources
   of functional types more plausible, and paths made out of
   a potentially unbounded number of applications of the same
   coercion.

   However, dynamic generation obviously introduces a great
   deal of work for the type-checker every time a coercion may
   need to be synthesised. (I say "may" since it is possible
   that a term is simply ill-typed!) I do not have much
   knowledge of the sort of graph-searching algorithms that would
   be required, but would suggest that even a very efficient and
   canny implementation would mean a substantial slow-down. The
   inefficient and clumsy implementation that I would make thus
   does not seem desirable. So static generation it is.

   I now move to the second design decision.

   A coercion is considered to be synthesisable for application to 
   a term if the type of that term matches the source type of the
   coercion. This sort of type-matching is not as general as type
   convertibility; it is more syntactic than that. If a type matches
   an unparameterised source type then it must be beta-convertible
   to it. We also allow unification of any meta-variables in the
   term's type. The extension to parameterised source types is that
   there should be a simple assignment of a LEGO term to each
   parameter that makes the types match.

   (It is also required on occasion to match two parameterised
   types together, when composing two paths in the coercive path
   to make a new one. In this case there must be an assignment to
   each of the sets of parameters that make the types match.)

   Why do I use this syntactically based type-matching, rather
   than type convertibility? There are three reasons.

   Firstly, although we may give the user a little more work, we
   also give em more control. There are occasions when one might
   want there to be different, incoherent coercions on types
   which although convertible are conceptually distinct; they
   are representations of different notions which happen to share
   the same form. This is easily accomplished using syntactic
   matching by simply giving the types different names.

   Secondly, there is again a pragmatic reason - I am trying to
   avoid too much of a slow-down. I am guessing that checking
   convertibility rather than the mostly syntactic matching that
   I have opted for would take rather longer.

   Thirdly, I believe that parameterisation of coercions is
   necessary for them to be very useful. Coercions to pi-types
   that apply functions that are bundled with appropriate proofs
   are a good example of very necessary parameterised coercions.
   Now, coherency checking is much more difficult for parameterised
   types if we use type-convertibility to join coercive paths.
   In particular, static coherency checking would appear to
   become undecideable. This is because I cannot in general know 
   whether or not there exists a value for x such that some
   parameterised type T(x) is convertible some other type. This
   problem is easily decided when using the syntactically-based
   matching however. Since I have opted for static generation,
   believe parameterisation to be valuable, and am concerned
   to keep LEGO running at a reasonable speed, I have chosen not
   to use type convertibility.
 *)

val coercion_debug = ref false;

structure Coercion : COERCION =
struct

(* Statically generated list of coercive paths, and interface. *)
val PATHS = ref([]: paths);
fun set_paths(co) = (PATHS := co);
fun get_paths() = (!PATHS);

(* Parameter assignments *)

(* Looks for value assigned to parameter i by assignment V. *)
fun assignment([],i) = NONE
  | assignment((j,x)::V,i) = if (i = j) then (SOME x) else assignment(V,i);

(* Assigns value x to parameter i in assignment V. *)
fun assign(V,i,x) = (i,x)::V;

(* Substitutes parameters in c as per the assignment V.
   If the flag full is set, requires that all parameters used
   in c have been assigned. If unset, it leaves unassigned
   parameters in c as they were.
 *)
fun sub_assign(full,V,c) =
let fun sa_rec (Param(n,id,t))   =
 (case (assignment(V,(n,id))) of
    NONE => if full
	    then bug ("sub_assign: unassigned parameter")
	    else Param (n,id,sa_rec t)
  | SOME x => sa_rec x)
      | sa_rec (Proj(p,x))      = Proj(p,sa_rec x)
      | sa_rec (Bind(vs,x,v,t)) = Bind(vs,x,sa_rec v,sa_rec t)
      | sa_rec (App((f,l),vs))  = App((sa_rec f,map sa_rec l),vs)
      | sa_rec (Tuple(x,l))     = Tuple (sa_rec x,map sa_rec l)
      | sa_rec (CnLst l)        = CnLst (map sa_rec l)
      | sa_rec (RedTyp(i,x))    = RedTyp(i,sa_rec x)
      | sa_rec (LabVT(l,v,t))   = LabVT(l,sa_rec v,sa_rec t)
      | sa_rec (Case(v,bs))     = Case(sa_rec v,sa_rec bs)
      | sa_rec x                = x
in sa_rec c
end;

(* An auxilliary function that checks to see whether a term mentions 
   the parameter p.
 *)
fun mentions_param p = 
    let fun mp_rec (Param q)       = (p = q)
	  | mp_rec (App((c,cs),_)) = (mp_rec c) orelse (exists mp_rec cs)
	  | mp_rec (Bind(_,_,c,d)) = (mp_rec d) orelse (mp_rec c)
	  | mp_rec (Tuple(T,l))    = (mp_rec T) orelse (exists mp_rec l) 
	  | mp_rec (CnLst l)       = exists mp_rec l
	  | mp_rec (Proj(_,c))     = mp_rec c
	  | mp_rec (RedTyp(_,c))   = mp_rec c
	  | mp_rec (LabVT(_,v,t))  = mp_rec v orelse mp_rec t
	  | mp_rec (Case(v,bs))    = mp_rec v orelse mp_rec bs
	  | mp_rec _               = false
in mp_rec
end;

(* Matching of types *)

(* Given the meta-variable substitution sb, try to match the pairs of
   types (s,t) in the given list. The types s may contain parameters and
   the types t may contain meta-variables. The match is an exact
   syntactic one apart from beta-conversions, an assignment to parameters
   and possible unification to resolve meta-variables.
   A successful match returns the parameter assignment used and an
   updated meta-variable substitution.
 *)
fun matches(sb,ms) =
let fun m_rec(V,_,[]) = SOME V
      | m_rec(V,_,(Param(n,id,t),x')::ms) =
 (case (assignment(V,(n,id))) of
      NONE   => (* Not yet assigned, so assign, and match their types *)
	m_rec(assign(V,(n,id),x'),true,(t,type_of_constr x')::ms)
    | SOME x => (* Already assigned, so use that assignment *)
	m_rec(V,true,(x,x')::ms))
      | m_rec(V,_,(_,Param _)::_) =
  bug "matches: parameter found on rhs"
      | m_rec(V,_,(Var(i,t),x')::ms) =
  m_rec(V,true,(t,type_of_constr x')::ms)
      | m_rec(V,_,(x,Var(i,t))::ms) =
  m_rec(V,true,(type_of_constr x,t)::ms)
      | m_rec(V,true,(App x,App x')::ms) =
(* Try putting both applications in dnf before matching *)
  m_rec(V,false,(dnf_co (App x),dnf_co (App x'))::ms)
      | m_rec(V,false,(App((f,l),vs),App((f',l'),vs'))::ms) =
  if (length vs = length vs')
  then m_rec(V,true,(ListUtil.zip(f::l,f'::l')) @ ms) else NONE
      | m_rec(V,true,(App x,x')::ms) =
(* Try putting lhs application in dnf before matching *)
  m_rec(V,false,(dnf_co (App x),x')::ms)
      | m_rec(_,false,(App _,_)::_) = NONE
      | m_rec(V,true,(x,App x')::ms) =
(* Try putting rhs application in dnf before matching *)
  m_rec(V,false,(x,dnf_co (App x'))::ms)
      | m_rec(_,false,(_,App _)::_) = NONE
      | m_rec(V,_,(Ref b,Ref b')::ms) =
  if (sameRef b b') then m_rec(V,true,ms) else NONE
      | m_rec(V,_,(Proj(p,x),Proj(p',x'))::ms) =
  if (p = p') then m_rec(V,true,(x,x')::ms) else NONE
      | m_rec(V,_,(Bind((b,_),_,v,t),Bind((b',_),_,v',t'))::ms) =
  if (b = b') then m_rec(V,true,(v,v')::(t,t')::ms) else NONE
      | m_rec(V,_,(CnLst l,CnLst l')::ms) =
  m_rec(V,true,(ListUtil.zip(l,l')) @ ms)
      | m_rec(V,_,(RedTyp(i,x),RedTyp(i',x'))::ms) =
  if (i = i') then m_rec(V,true,(x,x')::ms) else NONE
      | m_rec(V,_,(LabVT(l,v,t),LabVT(l',v',t'))::ms) =
  if (l = l') then m_rec(V,true,(v,v')::(t,t')::ms) else NONE
      | m_rec(V,_,(Case(v,bs),Case(v',bs'))::ms) =
  m_rec(V,true,(v,v')::(bs,bs')::ms)
      | m_rec(V,_,(x,x')::ms) =
  if (x = x') then m_rec(V,true,ms) else NONE
fun unifs(sb,V,[]) = SOME(sb,V)
  | unifs(sb,V,(s,s')::us) =
  case (unifs(sb,V,us)) of
     NONE => NONE
   | SOME(sb1,_) => case (type_match_unif sb1 (sub_assign(true,V,s)) s') of
		      NONE => NONE
		    | SOME sb2 => SOME (sb2,V)
in case (m_rec([],true,ms)) of
     NONE => NONE
   | SOME V => unifs(sb,V,ms)
end;

(* Try to match the pairs of types (s,t) in the given list. Both
   types may contain parameters, which should be differently tagged
   to get a sensible result. The match is an exact syntactic one
   apart from beta-conversions and the parameter assignments.
   A successful match returns the parameter assignment used.
 *)
fun matches2(ms) =
let fun m_rec(V,_,[]) = SOME V
      | m_rec(V,_,(Param(p as (n,id,t)),x')::ms) =
  if (x' = Param p) then m_rec(V,true,ms) else
 (case (assignment(V,(n,id))) of
      NONE   => (* Not yet assigned, so assign, and match their types *)
	let val new_x' = sub_assign(false,V,x')
	in if (x' = new_x')
	   then if (mentions_param p x')
		then NONE (* case when x' is Param p already succeeded *)
		else m_rec(assign(V,(n,id),x'),true,(t,type_of_constr x')::ms)
	   else m_rec(V,true,(Param p,new_x')::ms)
	end
    | SOME x => (* Already assigned, so use that assignment *)
	m_rec(V,true,(x,x')::ms))
      | m_rec(V,_,(x,Param p')::ms) = m_rec(V,true,(Param p',x)::ms)
      | m_rec(V,_,(Var _,_)::ms) =
  bug "match2: meta-variable found!"
      | m_rec(V,_,(_,Var _)::ms) =
  bug "match2: meta-variable found!"
      | m_rec(V,true,(App x,App x')::ms) =
(* Try putting both applications in dnf before matching *)
  m_rec(V,false,(dnf_co (App x),dnf_co (App x'))::ms)
      | m_rec(V,false,(App((f,l),vs),App((f',l'),vs'))::ms) =
  if (length vs = length vs')
  then m_rec(V,true,(ListUtil.zip(f::l,f'::l')) @ ms) else NONE
      | m_rec(V,true,(App x,x')::ms) =
(* Try putting lhs application in dnf before matching *)
  m_rec(V,false,(dnf_co (App x),x')::ms)
      | m_rec(_,false,(App _,_)::_) = NONE
      | m_rec(V,true,(x,App x')::ms) =
(* Try putting rhs application in dnf before matching *)
  m_rec(V,false,(x,dnf_co (App x'))::ms)
      | m_rec(_,false,(_,App _)::_) = NONE
      | m_rec(V,_,(Ref b,Ref b')::ms) =
  if (sameRef b b') then m_rec(V,true,ms) else NONE
      | m_rec(V,_,(Proj(p,x),Proj(p',x'))::ms) =
  if (p = p') then m_rec(V,true,(x,x')::ms) else NONE
      | m_rec(V,_,(Bind((b,_),_,v,t),Bind((b',_),_,v',t'))::ms) =
  if (b = b') then m_rec(V,true,(v,v')::(t,t')::ms) else NONE
      | m_rec(V,_,(Tuple(x,l),Tuple(x',l'))::ms) =
  m_rec(V,true,(ListUtil.zip(x::l,x'::l')) @ ms)
      | m_rec(V,_,(CnLst l,CnLst l')::ms) =
  m_rec(V,true,(ListUtil.zip(l,l')) @ ms)
      | m_rec(V,_,(RedTyp(i,x),RedTyp(i',x'))::ms) =
  if (i = i') then m_rec(V,true,(x,x')::ms) else NONE
      | m_rec(V,_,(LabVT(l,v,t),LabVT(l',v',t'))::ms) =
  if (l = l') then m_rec(V,true,(v,v')::(t,t')::ms) else NONE
      | m_rec(V,_,(Case(v,bs),Case(v',bs'))::ms) =
  m_rec(V,true,(v,v')::(bs,bs')::ms)
      | m_rec(V,_,(x,x')::ms) =
  if (x = x') then m_rec(V,true,ms) else NONE
in m_rec([],true,ms)
end;

(* Synthesis of coercions *)

(* Coerces a term (v : t) with a coercive path body c under the
   parameter assignment V, naming the argument arg.
 *)
fun coerce(V,c,v,t,argname)
 = MkApp((Bind((Lda,Vis),argname,t,sub_assign(true,V,c)),[v]),[CoShow]);

(* Search for a coercion in the list co whose source matches the
   type s and whose target matches the type t, where the matches
   are carried out using the matching function m. (It will be
   matches or matches2 in practice.) If successful, return the
   path in question along with the matching information.
 *)
fun arg_coercion (co,m,v,s,t) =
let fun argc_rec [] = NONE
      | argc_rec ((_,p)::l)
 = case (m [(path_source p,s),(path_target p,t),(Param (path_arg p),v)]) of
     NONE => argc_rec l
   | SOME x => SOME(p,x)
in argc_rec co
end;

(* Search as above, this time for any coercion to kinds from s'. *)
fun kind_coercion(co,m,v,s) =
let fun kindc_rec [] = NONE
      | kindc_rec ((_,p)::l)
 = if (path_flav p = KindCo)
   then (case (m [(path_source p,s),(Param (path_arg p),v)]) of
     NONE => kindc_rec l
   | SOME x => SOME(p,x))
   else kindc_rec l
in kindc_rec co
end;

(* Search as above, this time for any coercion to pi-types from s'. *)
fun pi_coercion(co,m,v,s) =
let fun pic_rec [] = NONE
      | pic_rec ((_,p)::l)
 = if (path_flav p = PiCo)
   then (case (m [(path_source p,s),(Param (path_arg p),v)]) of
     NONE => pic_rec l
   | SOME x => SOME(p,x))
   else pic_rec l
in pic_rec co
end;

(* Attempt to synthesise a coercion from s to t to apply to the
   argument v under the substitution sb. If successful, return
   the application of the coercion to v together with an updated
   substitution.
 *)
fun arg_co (sb,v,s,t) =
((if (!coercion_debug)
 then (prs "arg_co: looking between "; legoprint s;
       prs "and ";legoprint t)
 else ());
case (arg_coercion (get_paths(),(fn ms => matches(sb,ms)),v,s,t)) of
  SOME (p,(sb,S)) => SOME (coerce(S,path_body p,v,s,path_argname p),sb)
| NONE => NONE);

(* Attempt to synthesise a coercions from s to kinds to apply to
   the argument v under the substitution sb. This time a success
   also returns the type of the resulting application.
 *)
fun kind_co (sb,v,s) =
((if (!coercion_debug)
 then (prs "kind_co: looking from "; legoprint s)
 else ());
case (kind_coercion (get_paths(),(fn ms => matches(sb,ms)),v,s)) of
  SOME (p,(sb,S))
       => SOME (coerce(S,path_body p,v,s,path_argname p),
                sb,sub_assign(true,S,path_target p))
| NONE => NONE);

(* As above, this time synthesising a coercion to pi-types. *)
fun pi_co (sb,v,s) =
((if (!coercion_debug)
 then (prs "pi_co: looking from "; legoprint s)
 else ());
case (pi_coercion (get_paths(),(fn ms => matches(sb,ms)),v,s)) of
  SOME (p,(sb,S))
       => SOME (coerce(S,path_body p,v,s,path_argname p),
                sb,sub_assign(true,S,path_target p))
| NONE => NONE);

(* Search in the list of paths co for a coercion in competition
   with one of flavour flav between the parameterised types s
   and t.
 *)
fun competing_co (co,flav,v,s,t) =
case flav of
       ArgCo => arg_coercion (co,matches2,v,s,t)
     | KindCo => kind_coercion (co,matches2,v,s)
     | PiCo => pi_coercion (co,matches2,v,s);

(* Coercion declaration and generation *)

(* Add a new path p to an existing list of paths co. *)
fun add_path(p : path, co : paths)
 = co @ [(timestamp(),p)] : paths;

(* The body of the identity path, which does nothing *)
val id_path = Rel 1;

(* Extract a list of the parameters used in the list of terms cs. *)
fun list_parameters cs =
let fun lp_rec lp [] = lp
      | lp_rec lp ((Param p)::l) =
  if (exists (fn (n,id,_) => (n = param_tag p) andalso (id = param_name p)) lp)
  then lp_rec lp l
  else lp_rec (lp @ [p]) ((param_type p)::l)
      | lp_rec lp (Proj(p,x)::l)      = lp_rec lp (x::l)
      | lp_rec lp (Bind(_,_,v,t)::l)  = lp_rec lp (v::t::l)
      | lp_rec lp (App((f,xs),_)::l)  = lp_rec lp (f::(xs @ l))
      | lp_rec lp (Tuple(x,xs)::l)    = lp_rec lp (x::(xs @ l))
      | lp_rec lp ((CnLst xs)::l)     = lp_rec lp (xs @ l)
      | lp_rec lp (RedTyp(_,x)::l)    = lp_rec lp (x::l)
      | lp_rec lp (LabVT(_,v,t)::l)   = lp_rec lp (v::t::l)
      | lp_rec lp (Case(v,bs)::l)     = lp_rec lp (v::bs::l)
      | lp_rec lp (x::l)              = lp_rec lp l
in lp_rec [] cs
end;

(* Re-tags all parameters used in the list of terms cs with the
   value n, to distinguish them from those used in other
   parameterised types.
 *)
fun renaming_sub(n,cs) =
let fun rs_rec(rns,[]) = rns
      | rs_rec(rns,(m,id,t)::l) =
  if (n = m)
  then bug "renaming_sub: tags have same value"
  else rs_rec(assign(rns,(m,id),Param(n,id,t)),l)
    fun rn_rec [] = []
      | rn_rec ((p,Param(m,id,t))::l) =
    let val rest = rn_rec l
    in if exists (fn (_,Param q) => id = param_name q | _ => false) rest
       then rn_rec ((p,Param(m,id^"'",t))::l)
       else (p,Param(m,id,t))::(rn_rec l)
    end
      | rn_rec _ = bug "rn_rec!"
in rn_rec(rs_rec([],list_parameters cs))
end;

(* Simple auxilliary function for checking for repeated edges. *)
fun no_duplicates [] = true
  | no_duplicates (x::xs) = (no_duplicates xs) andalso
                            (for_all (fn y => not (x=y)) xs);

fun is_perm([],_,[]) = true
  | is_perm([],_,_) = false
  | is_perm(_,_,[]) = false
  | is_perm(x::xs,done,y::ys) = if (x = y)
                                then is_perm(xs,[],done @ ys)
                                else is_perm(x::xs,y::done,ys);

(* Attempts to add a new coercive path p to the list co, time
   stamping the addition with the stamp ts.

   If the source and target of the path can be matched, then
   the resulting coercion has to be the identity to be allowable.
   If there is already a coercion in competition with the new
   path, then they must "do the same thing"; i.e. the function
   bodies must be convertible.
   
   In both cases the new path is still added unless it is certain that
   the path will be redundant, as it is possible for coercions to
   compete in some situations but not in others. The notes inside the
   function definition explain how I make this decision.
 *)
fun should_add_path(p,co) =
(* Should not add the path if it contains any duplicate edges. *)
(case no_duplicates(path_edges p) of
  true => true
| false => (message "Ignored a path with a repeated edge"; false))
andalso
(* If the path always forms an identity cycle, it can be ignored.
   If it sometimes forms a non-identity cycle, it is incoherent.
   If it sometimes doesn't form a cycle, it should be added.

   The last can only be true if some of the parameters need to be
   assigned in order for the source and target to match.
 *)
(case(matches2[(path_source p,path_target p)]) of
    NONE => true (* add non-cycle *)
  | SOME S => let val c = sub_assign(false,S,path_body p)
	      in (prs "source can match target in ";
                  print_path p;
		  print_assign(S,path_tag p);
                  print "Checking coherence... ";
		  if (type_match c id_path)
		  then (message "OK";
                        (length S > 0))   (* add if params assigned *)
		  else (message "problem: ";                        
			failwith "non-identity cycle generated"))
	      end) andalso
(* If the path always converts with a competitor, it can be ignored.
   If it sometimes fails to convert with a competitor, it is incoherent.
   If it sometimes has no competitors, it should be added.

   In fact I can check only whether the same competitor will compete in
   all cases. This occurs if the parameters of the competing paths
   have the same types after assignment, and possibly
   permutation. This isn't optimal as the first match may not be the
   most generic one, but I'm being nice to the user as it is.
 *)
     (case (competing_co(co,path_flav p,Param (path_arg p),
                         path_source p,path_target p)) of
    NONE => true (* add if no competitors *)
  | SOME (q,S) =>
       let val c = sub_assign(false,S,path_body p)
	   val d = sub_assign(false,S,path_body q)
           fun sub_in_pt x = sub_assign(false,S,param_type x) 
	   val _ = if (!coercion_debug)
		   then (prs "debug c = "; legoprint c;
			 prs "debug d = "; legoprint d)
		   else()
       in (print "Checking coherence... ";
	   if (type_match c d)
	   then (message "OK";
                 not(is_perm(map sub_in_pt (path_params p),[],
                             map sub_in_pt (path_params q)))
              (* add unless essentially the same params *) )
	   else (message "problem: ";
		 prs "Conflict between "; print_path q;
		 print_assign(S,path_tag q);
		 prs "and "; print_path p;
		 print_assign(S,path_tag p);
		 failwith "incoherent paths generated"))
       end);

fun try_add_path(ts,p, co : paths)
= if (should_add_path(p,co)) then (co @ [(ts,p)]) else co;

(* This composes the paths p and q, whose target and source are
   assumed to have matched under the parameter assignment S, to
   produce a new path.
 *)
fun compose_paths(p,q,S) =
let val join = sub_assign(false,S,dnf(subst1 (path_body p) (path_body q)))
    val old_source = sub_assign(false,S,path_source p)
    val old_target = sub_assign(false,S,path_target q)
    val ts = timestamp();
    val R = renaming_sub(ts,[join,old_source,Param (path_arg p)])
    val new_join = sub_assign(false,R,join)
    val new_source = sub_assign(false,R,old_source)
    val new_target = sub_assign(false,R,old_target)
    val new_arg = case (sub_assign(false,R,Param (path_arg p)))
                  of Param p => (ts,param_name p,new_source)
                   | _ => bug"compose_paths: lost argument"
    val new_params = list_parameters [new_join,new_source]
    val new_edges = (path_edges p) @ (path_edges q)
in Path{arg=new_arg,target=new_target,body=new_join,
        params=new_params,edges=new_edges,flav=path_flav q}
end;

(* Generate all the new coercions formed by adding the path p into
   an existing list co. It would be possible to generate infinitely
   many paths under certain cirumstances by repeatedly applying
   this algorithm. I choose to compose the new path p with anything
   that fits on either or both sides.
 *)
fun generate_new_paths (id,p,co) =
let fun sources_rec [] = []
      | sources_rec((_,q)::l) =
  case (matches2[(path_source p,path_target q)]) of
   NONE => sources_rec l
 | SOME S => (compose_paths(q,p,S))::(sources_rec l)
    fun targets_rec [] = []
      | targets_rec((_,q)::l) =
  case (matches2[(path_source q,path_target p)]) of
   NONE => targets_rec l
 | SOME S => (compose_paths(p,q,S))::(targets_rec l)
    fun add_rec ps [] = ps
      | add_rec ps (p::l) = add_rec (try_add_path(timestamp(),p,ps)) l
    val subresult = add_rec co (p::(sources_rec co))
    val result = add_rec subresult (targets_rec subresult)
in (message ("The coercion "^id^" caused no incoherencies"); result)
end;

(* We take an ordered list of parameters params and a type x that
   contains references to de Bruijn variables, and replace these
   with the parameters.
 *)
fun parameterise_type params x =
  let fun pt_rec [] t = t
	| pt_rec (p::params) t = subst1 (Param p) (pt_rec params t)
  in pt_rec params x
  end;

(* We take the type of a term that has been declared as a coercion
   and extract a parameterised source and target type for it along
   with a list of parameters. Note that implicit arguments are
   considered to be the parameters, and the first explicit
   argument the source. We give default names to any unnamed arguments
   and also consider s as a final last parameter in t. (Thus dependent
   coercions are allowed.)
 *)
val strip_parameters =
let fun sp_rec params (n,Bind((Pi,vis),id,s,t)) =
    let val name = if (id = "")
		   then "Arg" ^ (makestring (1 + length params))
		   else id
	val p = (n,name,parameterise_type params s)
    in if (vis = Hid)
       then sp_rec (params @ [p]) (n,t)
       else (p, parameterise_type (params @ [p]) t, params)
    end
  | sp_rec _ _ = failwith "coercions must be functions"
in sp_rec []
end;

(* We take an ordered list of parameters params and a function body
   term x, and insert the parameters into the body by repeated
   application.
 *)
fun parameterise_value params x =
  let fun pv_rec [] v = v
	| pv_rec (p::ps) v = MkApp((pv_rec ps v,[Param p]),[NoShow])
  in dnf(pv_rec params x)
  end;

(* Checks whether the type t is functional. *)
fun is_function_type c =
(fn (Bind((Pi,_),_,_,_)) => true | _ => false) (whnf c);

(* Checks whether all the parameters params can be synthesised from
   a term of type c, in order.
 *)
fun can_synthesise(params,c) =
let fun cs_rec p (Param q) = (p = q) orelse (cs_rec p (param_type q))
      | cs_rec p (Bind (_,_,v,t))  = exists (cs_rec p) [v,t]
      | cs_rec p (App((f,l),_)) = exists (cs_rec p) (f::l)
      | cs_rec p (Tuple(x,l)) = exists (cs_rec p) (x::l)
      | cs_rec p (CnLst l) = exists (cs_rec p) l
      | cs_rec p (Proj(_,x)) = cs_rec p x
      | cs_rec p (RedTyp(_,x)) = cs_rec p x
      | cs_rec p (LabVT(_,v,t)) = exists (cs_rec p) [v,t]
      | cs_rec p (Case(v,bs)) = exists (cs_rec p) [v,bs]
      | cs_rec _ _ = false
in for_all (fn p => cs_rec p c) params
end;

(* Takes a term fv of type ft and attempts to use it as
   a declaration to add all the new paths generated by adding a 
   new coercion id of flavour flav to the existing list co.
 *)
fun add_paths((fv,ft,id,flav),co) =
let val (arg,target,params) = strip_parameters(timestamp(),ft)
    val _ = if ((flav = KindCo) andalso (not (kind target)))
	    then failwith "kind-coercion target must be a kind"
	    else ()
    val _ = if ((flav = PiCo) andalso (not (is_function_type target)))
	    then failwith "pi-coercion target must be a function type"
	    else ()
    val _ = if (not (can_synthesise(params,param_type arg)))
	    then failwith "parameters must be synthesisable from argument"
	    else ()
    val c = Path{arg=arg,target=target,
	    body=dnf(MkApp((parameterise_value params fv,[Rel 1]),[ShowNorm])),
	    params=params,edges=[id],flav=flav}
in generate_new_paths(id,c,co)
end;

(* The variable for the coercive graph plus an interface to this to
   enable it to be set and to produce lists of paths that match
   certain criteria.
 *)

(* Returns a list of all paths whose targets match y. *)
fun get_paths_to y =
let fun is_path_to (X as (_,p)) = case matches([],[(path_target p,y)]) of
  NONE => NONE
| SOME _ => SOME X
in ListUtil.filter is_path_to (get_paths())
end;

(* Returns a list of all paths whose sources match x. *)
fun get_paths_from x =
let fun is_path_from (X as (_,p)) = case matches([],[(path_source p,x)]) of
  NONE => NONE
| SOME _ => SOME X
in ListUtil.filter is_path_from (get_paths())
end;

(* The intersection of the above two criteria. *)
fun get_paths_between(x,y) =
let fun is_path_between (X as (_,p)) =
 case matches([],[(path_source p,x),(path_target p,y)]) of
  NONE => NONE
| SOME _ => SOME X
in ListUtil.filter is_path_between (get_paths())
end;

end; (* struct Coercion *)
